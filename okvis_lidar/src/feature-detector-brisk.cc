#include "okvis/lidar/feature-detector-brisk.h"

#include <memory>
#include <string>
#include <vector>

#include <Eigen/Core>
#include <brisk/brisk.h>
#include <glog/logging.h>
#include <opencv2/core/core.hpp>
#include <opencv2/features2d/features2d.hpp>
#include <opencv2/imgproc.hpp>

#include "okvis/lidar/helpers.h"
#include "okvis/lidar/key-point-bucketing.h"
#include <algorithm>
#include <iostream>

namespace okvis {
namespace lidar {

FeatureDetectorBrisk::FeatureDetectorBrisk(
    const FeatureDetectorBriskSettings &settings)
    : settings_(settings) {
  detector_.reset(
      new brisk::ScaleSpaceFeatureDetector<brisk::HarrisScoreCalculator>(
          settings.num_pyramid_levels, settings.uniformity_radius,
          settings.absolute_threshold, kMaxDetection));
}

void FeatureDetectorBrisk::detectFeatures(const cv::Mat &image,
                                          size_t num_features,
                                          const cv::Mat &mask,
                                          KeyframeFeatures *keyframe) {
  CHECK_NOTNULL(keyframe);
  CHECK_LE(num_features, kMaxDetection) << "Increase kMaxDetection!";

  // Detect some keypoints.
  std::vector<cv::KeyPoint> keypoints;
  detector_->detect(image, keypoints, mask);

  // Select the best keypoints in a grid.
  size_t num_buckets_u = 4u;
  size_t num_buckets_v = 4u;

  struct CvKeyPointGreaterThan {
    bool operator()(const cv::KeyPoint &a, const cv::KeyPoint &b) {
      return a.response > b.response;
    }
  };
  KeyPointBucketing<cv::KeyPoint, CvKeyPointGreaterThan>(
      image.rows, image.cols, num_features, num_buckets_u, num_buckets_v,
      &keypoints);
  CHECK_LE(keypoints.size(), num_features);

  // Convert keypoints.
  CvKeypointsToKeyframeFeatures(keypoints, keyframe);
}

} // namespace lidar
} // namespace okvis
